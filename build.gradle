/*
 * This build file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at https://docs.gradle.org/3.4.1/userguide/tutorial_java_projects.html
 */

// Plugins services intégration
plugins {
    id "org.sonarqube" version "2.4"
}

project.group = 'fr.esgi.projet.softwareneedsyou'

//allprojects  pour le projet actuel et les projets en dépendance
//subprojects  pour tous les projets en dépendance

subprojects {
    // Apply the java plugin to add support for Java
    apply plugin: 'java'

    // Support des IDEs
    //apply plugin: 'eclipse'
    //tasks.eclipse.dependsOn cleanEclipse
    //tasks.eclipseClasspath.dependsOn initProject
    //apply plugin: 'idea'

    // Plugins de test
    apply plugin: 'findbugs'
    apply plugin: 'jacoco'

    //manifest.mainAttributes(provider: 'gradle')
    //appendix = archiveName
    //archivesBaseName = "softwareneedsyou"

    // On spécifie la version de Java à utiliser
    sourceCompatibility = JavaVersion.VERSION_1_8 //1.8
    targetCompatibility = JavaVersion.VERSION_1_8 //1.8

    // In this section you declare where to find the dependencies of your project
    repositories {
        // Use jcenter for resolving your dependencies.
        jcenter()
        // You can declare any Maven/Ivy/file repository here.
        //mavenCentral()
    }

    ext {
        lombockVersion = '1.16.+'

        //Logging
        // ...

        //Testing
        junitVersion = '4.+'
    }

    dependencies {
        // This dependency is found on compile classpath of this component and consumers.
        //compile 'com.google.guava:guava:20.0'

        // Use JUnit test framework
        testCompile "junit:junit:$junitVersion"
        
        compileOnly "org.projectlombok:lombok:$lombockVersion"
    }

    jar {
        manifest {
            attributes 'Implementation-Title': project.name,
                'Implementation-Version': "$version"
        }
    }

    test {
        afterTest { desc, result ->
            if(result.resultType  == TestResult.ResultType.FAILURE) {
                logger.quiet("${result.resultType} : ${desc.name}(${desc.className}) -> ${result.exception.message}" )
            }
        }
    }

    task testsJar(type: Jar, dependsOn: testClasses) {
        description = 'Assembles a jar archive containing the test classes.'
        classifier = 'tests'
        //from sourceSets.test.classes
        from sourceSets.test.output
    }

    task sourcesTestJar(type: Jar /*, dependsOn: testClasses*/) {
        description = 'Assembles a jar archive containing the test source classes.'
        classifier = 'test-sources'
        from sourceSets.test.allSource
    }

    task sourcesJar(type: Jar /*, dependsOn: classes*/) {
        description = 'Assembles a jar archive containing the main source classes.'
        classifier = 'sources'
        from sourceSets.main.allSource
    }

    artifacts {
        archives sourcesJar
        archives testsJar
        archives sourcesTestJar
    }

    task release(description: 'fige une version avant son déploiement') {}
 
    gradle.taskGraph.whenReady {taskGraph ->
        if (taskGraph.hasTask(release)) {
            version = version
        } else {
            version += "-SNAPSHOT"
        }
    }

    sonarqube {
        properties {
            //property "sonar.projectKey", "org.sonarqube:java-gradle-simple"
            property "sonar.sourceEncoding", "UTF-8"
            //property "sonar.sources", "src"
            //properties["sonar.sources"] += sourceSets.custom.allSource.srcDirs
            //properties["sonar.tests"] += sourceSets.integTest.allSource.srcDirs
        }
    }

    findbugs {
        toolVersion = "3.0.1" //pour compactibilité jre 1.7
        effort = "max"
        reportLevel = "low"
        ignoreFailures = true //sinon echec de la compilation
        reportsDir = file("${buildDir}/findbugsReports") //$project.buildDir, default=build/reports/findbugs/
    }

    tasks.withType(FindBugs) {
        reports {
            xml.enabled = false
            html.enabled = true
        }
    }

    build.finalizedBy(jacocoTestReport) //pour exécuter automatique le test de couverture (avec junit) après la compilation

    jacocoTestReport {
        group = "Reporting"
        description = "Générer un rapport de couverture de code (JAvaCOdeCOverage) après les tests"
        additionalSourceDirs = files(sourceSets.main.allJava.srcDirs)
        reports {
            xml.enabled false
            csv.enabled false
            html.enabled true
            html.destination "${buildDir}/jacocoHtml"
        }
        doFirst {
            sourceDirectories = files(classDirectories.files.collect {
                fileTree(dir: it, exclude: ['**/tri/**Exception**'])
            })
            classDirectories = files(classDirectories.files.collect {
                fileTree(dir: it, exclude: ['**/tri/**Exception**'])
            })
        }
        afterEvaluate { //pas vraiment nécessaire avec doFirst
            classDirectories = files(classDirectories.files.collect {
                fileTree(dir: it, exclude: ['**/tri/**Exception**'])
            })
        }
    }
}
